import matplotlib.pyplot as pltimport numpy as npfrom scipy.spatial.distance import cdistfrom sklearn.decomposition import PCAfrom sklearn.cluster import KMeansimport outputsdef read_file(file_address):    ballot_file = open(file_address, "r")    lines = ballot_file.readlines()    # Remove num candidates and votes per ballot    first_line = lines[0].split(' ')    lines.remove(lines[0])    lines.remove(lines[1])    lines.remove(lines[-1])    return lines, int(first_line[0]), int(first_line[1])def get_ballots_and_candidates(file_address):    """Get ballots and candidates as lists"""    lines, num_candidates, num_seats = read_file(file_address)    ballots = [[0] * num_candidates for i in range(332)]    candidates = {}    is_ballot = True    ballot_num = 0    for ballot in lines:        if ballot == '0\n':            is_ballot = False            continue        if is_ballot:            ballot = ballot.replace('\n', '')            votes = [int(i) for i in ballot.split(' ')][1:-1]            if votes:                ballots[ballot_num] = votes                ballot_num += 1        else:            candidate = ballot.replace('"', '').replace('\n', '')            candidates[len(candidates)] = candidate    return ballots, candidates, num_candidates, num_seatsdef get_slate_keys(slate, candidates):    candidate_names = list(candidates.values())    return [[candidate_names.index(candidate) + 1 for candidate in slate[0]]]def vectorize_matrix(ballots, num_candidates):    """Transform ballots into 'rank' matrices. The first candidate voted for by a voter gets rank 44.    The last gets 1. Anyone not voted for gets 0"""    vectorized_ballots = [[0] * num_candidates for i in range(len(ballots))]    for ballot_num in range(len(ballots)):        ballot = ballots[ballot_num]        value = num_candidates        for vote_num in range(len(ballot)):            vectorized_ballots[ballot_num][ballot[vote_num] - 1] = value            value -= 1    return vectorized_ballotsdef do_pca(transformed_ballots):    array = np.array(transformed_ballots)    pca = PCA(n_components=15)    reduced_array = pca.fit_transform(array)    return reduced_array, pcadef pick_number_nodes(pca_array):    cluster_variances = []    cluster_choices = range(1, 10)    for i in cluster_choices:        kmeans_model = KMeans(n_clusters=i, n_init=100).fit(pca_array)        cluster_variances.append(            100 - sum(np.min(cdist(pca_array, kmeans_model.cluster_centers_, 'euclidean'), axis=1)) /            pca_array.shape[0])    plt.plot(cluster_choices, cluster_variances, 'bx-')    plt.xlabel('Number of Nodes')    plt.ylabel('Variance Explained')    plt.title('The Elbow Method showing the optimal k')    plt.savefig('output_files/2021/node_numbers.png')def split_clusters(reduced_array, cluster_labels, num_clusters):    clusters = []    for i in range(num_clusters):        index = [j for j, x in enumerate(cluster_labels) if x == i]        clustered_votes = np.array([list(reduced_array[j]) for j in index])        clusters.append(clustered_votes)    return clustersdef get_vote_counts_for_candidate(ballots, num_candidates):    counts = np.zeros((num_candidates, num_candidates + 1), dtype=np.int8)    for i in range(num_candidates):        votes_for_candidate = ballots[:, int(i)]        for vote in votes_for_candidate:            counts[i][vote] += 1    return countsdef get_clustered_vote_counts(clusters, num_candidates):    return [get_vote_counts_for_candidate(np.array(cluster), num_candidates) for cluster in clusters]def vote_counts(vote_cast, counts, ballots, ballot_index, i, max_value):    return len(ballots[ballot_index]) > i and np.array(counts[ballots[ballot_index][i] - 1]).sum() < max_value and not vote_cast[ballot_index]def get_cluster_counts(cluster_labels, num_clusters):    cluster_counts = [0] * num_clusters    for cluster in cluster_labels:        cluster_counts[cluster] += 1    return cluster_countsdef save_clusters(reduced_array, num_clusters):    kmeans = KMeans(n_clusters=num_clusters, n_init=100)    cluster_labels = kmeans.fit_predict(reduced_array)    np.save("output_files/2021/clusters/labels.npy", cluster_labels)    np.save("output_files/2021/clusters/centers.npy", kmeans.cluster_centers_)# 2021 slateslu_slate = [['Anlin Wang', 'Sal H', 'Julia Alekseyeva', 'Meag Jae Kaman', 'Ron Joseph', 'Austin Binns', 'Melissa Duvelsdorf',                     'Aliyah Bixby-Driesen', 'Michele Rossi', 'Shawn Hogan', 'Sanwal Yousaf', 'Emily Berkowitz', 'Matt Chewning',                     'Francisco Diez', 'Will M', 'Matthew Zanowic', 'Mike Dewar', 'Sam Layding', 'Patrick Wargo', 'Daisy Confoy', 'Rebecca Johnson']]br_slate = [['Bill Bradley', 'John Campbell', 'Amanda Fox', 'Dave Fox', 'Ethan Hill', 'K.T. Liberato']]num_clusters = 6cluster_names = {'LU': "r",                 'Momentum': "y",                 'Unaligned (big names)': "b",                 'LU Plus': "m",                 'Unaligned (random)': "c",                 'B&R + SA': "g"}ballots, candidates, num_candidates, num_seats = get_ballots_and_candidates("include/2021ballots.txt")print(candidates)lu_slate_keys = get_slate_keys(lu_slate, candidates)br_slate_keys = get_slate_keys(br_slate, candidates)vectorized_ballots = vectorize_matrix(ballots, num_candidates)pca_array, pca = do_pca(vectorized_ballots)cluster_labels = np.load("output_files/2021/clusters/labels.npy")cluster_centers = np.load("output_files/2021/clusters/centers.npy")reverted_clusters = pca.inverse_transform(cluster_centers)#outputs.write_diff_cluster_centers(reverted_clusters, candidates, cluster_names, [3, 0])outputs.write_cluster_centers(pca.inverse_transform(cluster_centers), candidates, cluster_names)vectorized_br_slate = vectorize_matrix(br_slate_keys, num_candidates)pca_br_slate = pca.transform(vectorized_br_slate)vectorized_lu_slate = vectorize_matrix(lu_slate_keys, num_candidates)pca_lu_slate = pca.transform(vectorized_lu_slate)rotated_slates = np.array([pca_br_slate[0], pca_lu_slate[0]])clusters = split_clusters(pca_array, cluster_labels, num_clusters)vote_clusters = split_clusters(vectorized_ballots, cluster_labels, num_clusters)cluster_counts = get_cluster_counts(cluster_labels, num_clusters)# query = {#     'Katie Bohri': 0# }# outputs.ballot_query(query, ballots, cluster_labels, cluster_names, candidates)outputs.plot_pca_ballots(np.array(clusters), rotated_slates, cluster_names)#outputs.print_totals(pca, cluster_counts, cluster_names)#votes = get_clustered_vote_counts(np.array(vote_clusters), num_candidates)#outputs.plot_vote_counts(votes, candidates, cluster_names)#outputs.write_pca_components(pca, candidates)#outputs.plot_important_components(pca, candidates)